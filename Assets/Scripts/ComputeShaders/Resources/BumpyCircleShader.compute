// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain
#include "MyHelpers.hlsl"


float2 Center;
float2 MinMax;
int BlendMode;
float4 PrimaryColor;
float4 SecondaryColor;
int ArrayLength;

float Radius;


StructuredBuffer<float> Rates;
StructuredBuffer<float> Amplitudes;
StructuredBuffer<float> Powers;
StructuredBuffer<float> Offsets;
StructuredBuffer<float> Constants;
StructuredBuffer<bool> UseAbsbools;
StructuredBuffer<bool> Enabled;



RWTexture2D<float4> Result;
float DistortionFactor;
RWTexture2D<float4> DistortionTex;


// this is sperated not because it needs to be but because of a reverted design decision
float4 BumpyCircle(float angle, uint2 pos, float4 startColor, float4 endColor)
{    
    
    uint2 DistortedPosition = DistortPos((DistortionTex[pos]), pos, DistortionFactor);

    float t = distance(DistortedPosition.xy, uint2(Center.x, Center.y));
    
    float height = 0;
    float Runningheight = 0;
    
    float angleSign = 1;
    
    
    float4 output = float4(1,1,1,1);
 
    
   
    if (t < MinMax.x)
    {
        output = Blend(Result[pos], startColor, startColor.w, BlendMode, true);
            
    }
    else if (t > ((MinMax.y > 0.01) ? MinMax.y : 100000.0))
    {
        output = Blend(Result[pos], endColor, endColor.w, BlendMode, true);

    }
    else
    {
        for (int i = 0; i < ArrayLength; i++)
        {
            if (Enabled[i])
            {
                height = sin(angle * round(Rates[i]) + Offsets[i]);
        

                height += Constants[i];
    
                if (!UseAbsbools[i])
                {
                    angleSign = sign(height);
                }
    
                height = pow(abs(height), Powers[i]) * angleSign;
        
                height *= Amplitudes[i];
        
                Runningheight += height;
            }
        }
            
        if ((t - Runningheight) < Radius)
        {
            output = Blend(Result[pos.xy], startColor, startColor.w, BlendMode, true);
        }
        else
        {
            output = Blend(Result[pos.xy], endColor, endColor.w, BlendMode, true);
        }
    
    }


    return output;
  
}

[numthreads(8, 8, 1)]

void CSMain (uint3 id : SV_DispatchThreadID)
{
    // TODO: insert actual code here!
    float angle = degrees(SignedAngle2D(id.xy - float2(Center.x, Center.y), float2(0.0, 1.0))) + 180;
    
    angle /= 360;
    angle *= (2 * PI);
    
    Result[id.xy] = BumpyCircle(angle, id.xy, PrimaryColor, SecondaryColor);
}

