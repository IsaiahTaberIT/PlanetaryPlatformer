// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain
#include "MyHelpers.hlsl"


float2 Center;
float2 MinMax;
int BlendMode;
float4 PrimaryColor;
float4 SecondaryColor;
int ArrayLength;
float Radius;

StructuredBuffer<float> Rates;
StructuredBuffer<float> Amplitudes;
StructuredBuffer<float> Powers;
StructuredBuffer<float> Offsets;
StructuredBuffer<float> Constants;
StructuredBuffer<bool> UseAbsbools;
StructuredBuffer<bool> Enabled;


RWTexture2D<float4> Result;
float DistortionFactor;
RWTexture2D<float4> DistortionTex;


// this is sperated not because it needs to be but because of a reverted design decision
float4 BumpyCircle(float angle, uint2 pos, float4 startColor, float4 endColor)
{    
    
    uint2 DistortedPosition = DistortPos((DistortionTex[pos]), pos, DistortionFactor);

    float t = distance(DistortedPosition.xy, uint2(Center.x, Center.y));
    
    float height = 0;
    float Runningheight = 0;
    
    
    float2 localminmax = MinMax;
    
    float max = 0;
    
    
    max = MinMax.y > 0.01 ? MinMax.y : 100000.0;
    
    if (true)
    {
        return Blend(Result[pos], startColor, startColor.w, BlendMode, true);
    }
    
    if (t > max)
    {
        return Blend(Result[pos], endColor, endColor.w, BlendMode, true);
    }

 
   

    
    for (int i = 0; i < ArrayLength; i++)
    {
        if (Enabled[i])
        {
            height = sin(angle * round(Rates[i]) + Offsets[i]);
        
            float angleSign = 1;

            height += Constants[i];
    
            if (!UseAbsbools[i])
            {
                angleSign = sign(height);
            }
    
            height = pow(abs(height), Powers[i]) * angleSign;
        
            height *= Amplitudes[i];
        
            //added this so it wont shrink the low end of circle when you make the amplitude larger
        
         //   height += Amplitudes[i];
        
            Runningheight += height;
        }
    }
            
    if ((t - Runningheight) < Radius)
    {
        return Blend(Result[pos.xy], startColor, startColor.w, BlendMode, true);
    }
    else
    {
        return Blend(Result[pos.xy], endColor, endColor.w, BlendMode, true);
    }
}

[numthreads(8, 8, 1)]

void CSMain (uint3 id : SV_DispatchThreadID)
{
    // TODO: insert actual code here!
    float angle = degrees(SignedAngle2D(id.xy - float2(Center.x, Center.y), float2(0.0, 1.0))) + 180;
    angle /= 360;
    angle *= (2 * PI);
    
    float4 endcolor = float4(1, 1, 1, 1);
    
    uint2 DistortedPosition = DistortPos((DistortionTex[id.xy]), id.xy, DistortionFactor);

    float t = distance(DistortedPosition.xy, uint2(Center.x, Center.y));
    
    float Spacing = 15;
    
    angle /= PI;
    angle /= 2;

    angle *= Radius;
    
    float mod = (absPow(t,1.5) + angle) % Radius;

    
    if (mod >= Radius / 2.0)
    {
        endcolor = Blend(Result[id.xy], PrimaryColor, PrimaryColor.w, BlendMode, true);
    }
    else
    {
        endcolor = Blend(Result[id.xy], SecondaryColor, SecondaryColor.w, BlendMode, true);
    }
        
    Result[id.xy] = endcolor;
    
    
       
   // Result[id.xy] = BumpyCircle(angle, id.xy, PrimaryColor, SecondaryColor);
}

