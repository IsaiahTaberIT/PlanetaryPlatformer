// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain
#include "MyHelpers.hlsl"
// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture
RWTexture2D<float4> Result;
RWTexture2D<float4> Noise;
int BlendMode;
float2 Dims;
float Seed;
float Scale;
float Alpha;
float4 BaseColor;
int NoiseDimensions;
float Power;
bool UseCoherentNoise;


float InverseLerp(float a, float b, float t)
{
    return (t - a) / (b - a);
    // (value - start) / (end - start)
}
   

float PerlinNoiseFromTex(uint2 id)
{
        
    uint localScale = Scale;
    uint2 quantizedPos = (id.xy / localScale) * localScale;
    
    
    uint offset =0 ;

    uint2 gridPos1 = floor(id.xy / Scale) + offset;
    uint2 gridPos2 = floor(id.xy / Scale) + uint2(1, 1) + offset;
    uint2 gridPos3 = floor(id.xy / Scale) + uint2(1, 0) + offset;
    uint2 gridPos4 = floor(id.xy / Scale) + uint2(0, 1) + offset;
   

    float2 cornerVectorDL = (Noise[gridPos1].rg * 2.0 - 1.0);
    float2 cornerVectorUR = (Noise[gridPos2].rg * 2.0 - 1.0);
    float2 cornerVectorDR = (Noise[gridPos3].rg * 2.0 - 1.0);
    float2 cornerVectorUL = (Noise[gridPos4].rg * 2.0 - 1.0);
    
    float2 posInGridDL = (id.xy % (float) localScale) / (float) localScale;
    float2 posInGridUR = posInGridDL - float2(1, 1);
    float2 posInGridDR = posInGridDL - float2(1, 0);
    float2 posInGridUL = posInGridDL - float2(0, 1);

    float cornerDotDL = dot((posInGridDL), normalize(cornerVectorDL));
    float cornerDotUR = dot((posInGridUR), normalize(cornerVectorUR));
    float cornerDotDR = dot((posInGridDR), normalize(cornerVectorDR));
    float cornerDotUL = dot((posInGridUL), normalize(cornerVectorUL));
    
    float x1 = lerp(cornerDotDL, cornerDotDR, EaseInOut(posInGridDL.x, Power)); // bottom
    float x2 = lerp(cornerDotUL, cornerDotUR, EaseInOut(posInGridDL.x, Power)); // top
    float y1 = lerp(x1, x2, EaseInOut(posInGridDL.y, Power));
    

    return y1 + 0.5;
}







    
float interpolatedValue(uint2 id)
{
        
        
    float2 posUR = float2((id.x) / Scale, (id.y) / Scale);
        
    float2 posUL = float2((id.x) / Scale, (id.y) / Scale);
        
    float2 posDR = float2((id.x) / Scale, (id.y) / Scale);
        
    float2 posDL = (id.xy / Scale);

        
    int indexUR = (int) floor(posUR.x + 1 + (posUR.y + 1) * Dims.x);
        
    int indexUL = (int) floor(posUL.x + (posUL.y + 1) * Dims.x);
        
    int indexDR = (int) floor(posDR.x + 1 + posDR.y * Dims.x);
        
    int indexDL = (int) floor(posDL.x + posDL.y * Dims.x);
    
    

 
    float2 v1 = float2(id.xy - floor((id.xy) / Scale) * Scale);
    v1 /= Scale;
    float v1t = length(v1);
    
    
    
   // float x1 = lerp(ValueGrid[indexUL], ValueGrid[indexUR], EaseInOut(v1.x, Power));
   // float x2 = lerp(ValueGrid[indexDL], ValueGrid[indexDR], EaseInOut(v1.x, Power));
    //float y1 = lerp(x1, x2, 1 - EaseInOut(v1.y, Power));
    
    
    
    float output = 0;
    float total = v1t;
   
    
    return 0;

}




[numthreads(8, 8, 1)]

void CSMain(uint3 id : SV_DispatchThreadID)
{
    
    
    
    // TODO: insert actual code here!

    float4 color = float4(0, 0, 0, 0);
 
  
    
    int index = (int) floor((id.x - Scale / 2) / Scale + (id.y * Dims.x) / Scale);
    
    if (UseCoherentNoise == true)
    {
      
      
        color = BaseColor * PerlinNoiseFromTex(id.xy);
    }
    else
    {
        uint2 quantizedpos = floor(id.xy / Scale) * Scale;
        if (NoiseDimensions == 1)
        {
            color = BaseColor * RandomValue(Dims.x, quantizedpos, Seed);
        
        }
        else if (NoiseDimensions == 2)
        {
            color = float4(BaseColor.r * RandomValue(Dims.x, quantizedpos, Seed), BaseColor.g * RandomValue(Dims.x, quantizedpos, Seed + 0.1), 0, 0);
        
        }
        else if (NoiseDimensions == 3)
        {
            color = float4(BaseColor.r * RandomValue(Dims.x, quantizedpos, Seed), BaseColor.g * RandomValue(Dims.x, quantizedpos, Seed + 0.1), BaseColor.b * RandomValue(Dims.x, quantizedpos, Seed + 0.2), 0);
        
        }
    }
    
    
 
    color.rgb = saturate(color.rgb);
    color.a = Alpha;
    
    Result[id.xy] = saturate(Blend(Result[id.xy], color, Alpha, BlendMode));
}



