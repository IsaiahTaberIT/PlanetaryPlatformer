// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain
#include "MyHelpers.hlsl"
// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture
RWTexture2D<float4> Result;
RWTexture2D<float4> Noise;
int BlendMode;
int NoiseBlendMode;

float2 Dims;
float Seed;
float Scale;
float Alpha;
float4 PrimaryColor;
float4 SecondaryColor;

int NoiseDimensions;
float Power;
bool UseCoherentNoise;


float PerlinNoiseFromTex(uint2 id)
{
        
    uint localScale = Scale;
    uint2 quantizedPos = (id.xy / localScale) * localScale;
    
    
    uint offset =0 ;

    uint2 gridPos1 = floor(id.xy / Scale) + offset;
    uint2 gridPos2 = floor(id.xy / Scale) + uint2(1, 1) + offset;
    uint2 gridPos3 = floor(id.xy / Scale) + uint2(1, 0) + offset;
    uint2 gridPos4 = floor(id.xy / Scale) + uint2(0, 1) + offset;
   

    float2 cornerVectorDL = (Noise[gridPos1].rg * 2.0 - 1.0);
    float2 cornerVectorUR = (Noise[gridPos2].rg * 2.0 - 1.0);
    float2 cornerVectorDR = (Noise[gridPos3].rg * 2.0 - 1.0);
    float2 cornerVectorUL = (Noise[gridPos4].rg * 2.0 - 1.0);
    
    float2 posInGridDL = (id.xy % (float) localScale) / (float) localScale;
    float2 posInGridUR = posInGridDL - float2(1, 1);
    float2 posInGridDR = posInGridDL - float2(1, 0);
    float2 posInGridUL = posInGridDL - float2(0, 1);

    float cornerDotDL = dot((posInGridDL), normalize(cornerVectorDL));
    float cornerDotUR = dot((posInGridUR), normalize(cornerVectorUR));
    float cornerDotDR = dot((posInGridDR), normalize(cornerVectorDR));
    float cornerDotUL = dot((posInGridUL), normalize(cornerVectorUL));
    
    float x1 = lerp(cornerDotDL, cornerDotDR, EaseInOut(posInGridDL.x, Power)); // bottom
    float x2 = lerp(cornerDotUL, cornerDotUR, EaseInOut(posInGridDL.x, Power)); // top
    float y1 = lerp(x1, x2, EaseInOut(posInGridDL.y, Power));
    

    return y1 + 0.5;
}

[numthreads(8, 8, 1)]

void CSMain(uint3 id : SV_DispatchThreadID)
{

    float4 color = float4(0, 0, 0, 0);
    
    int index = (int) floor((id.x - Scale / 2) / Scale + (id.y * Dims.x) / Scale);
    
    if (UseCoherentNoise == true)
    {
        color = Blend(PrimaryColor, SecondaryColor, PerlinNoiseFromTex(id.xy), NoiseBlendMode, false);
    }
    else
    {
        uint2 quantizedpos = floor(id.xy / Scale) * Scale;
        if (NoiseDimensions == 1)
        {
            color = SecondaryColor * RandomValue(Dims, quantizedpos, Seed);
        
        }
        else if (NoiseDimensions == 2)
        {
            color = float4(SecondaryColor.r * RandomValue(Dims, quantizedpos, Seed), SecondaryColor.g * RandomValue(Dims, quantizedpos, Seed + 1), 0, 0);
        
        }
        else if (NoiseDimensions == 3)
        {
            color = float4(SecondaryColor.r * RandomValue(Dims, quantizedpos, Seed), SecondaryColor.g * RandomValue(Dims, quantizedpos, Seed + 1), SecondaryColor.b * RandomValue(Dims, quantizedpos, Seed + 2), 0);
        
        }
    }
     
    color.rgb = saturate(color.rgb);
    
    color.a = PrimaryColor.w;
    
    Result[id.xy] = saturate(Blend(Result[id.xy], color, Alpha, BlendMode, true));
}



