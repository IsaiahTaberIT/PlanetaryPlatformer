// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain
#include "MyHelpers.hlsl"
// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture
bool Fuzzy;
int BlendMode;
bool DoRotLerp;
float2 Dims;
float Offset;
float4 PrimaryColor;
float4 SecondaryColor;
float Spacing;
float2 Slope;
float BlendPower;
int GradientBlendMode;

RWTexture2D<float4> Result;
float DistortionFactor;
RWTexture2D<float4> DistortionTex;

RWTexture2D<float4> SecondaryInputTexture; // SIT
bool OverrideWithMask; // OWM
bool OverridePrimaryColor; // OPC

[numthreads(8, 8, 1)]

void CSMain (uint3 id : SV_DispatchThreadID)
{
    HandleMasking(OverrideWithMask, OverridePrimaryColor, PrimaryColor, SecondaryColor, SecondaryInputTexture[id.xy]);
    uint2 DistortedPosition = DistortPos((DistortionTex[id.xy] + 0.5) / 4.0, id.xy, DistortionFactor);

    float mod = (((DistortedPosition.x) - Dims.x / 2.0) * Slope.x + ((DistortedPosition.y) - Dims.y / 2.0) * Slope.y + length(Dims) * 10.0 + Offset) % Spacing;
    float4 endcolor = float4(1, 1, 1, 1);
    if (!Fuzzy)
    {
        if (mod >= Spacing / 2.0)
        {
            endcolor = Blend(Result[id.xy], PrimaryColor, PrimaryColor.w, BlendMode, true);
        }
        else
        {
            endcolor = Blend(Result[id.xy], SecondaryColor, SecondaryColor.w, BlendMode, true);
        }
        
        Result[id.xy] = endcolor;
    }
    else
    {
        float shiftedmod = ((mod + (Spacing * 0.75))) % Spacing;
        float t = abs((shiftedmod / (Spacing / 2.0)) - 1);
        t = EaseInOut(t, BlendPower);
        endcolor = Result[id.xy] = Blend(PrimaryColor, SecondaryColor, t, GradientBlendMode, false);
        Result[id.xy] = Blend(Result[id.xy], endcolor, endcolor.w, BlendMode, true);

    }
}
