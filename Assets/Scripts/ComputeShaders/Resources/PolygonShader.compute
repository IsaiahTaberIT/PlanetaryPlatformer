// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain

#include "MyHelpers.hlsl"

// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture

int BlendMode;
float2 Dims;
float4 PrimaryColor;
float4 SecondaryColor;
RWTexture2D<float4> Result;
float DistortionFactor;
RWTexture2D<float4> DistortionTex;
RWTexture2D<float4> SecondaryInputTexture; // SIT
bool OverrideWithMask; // OWM
bool OverridePrimaryColor; // OPC







float inverseLerp(float start, float end, float value)
{
    return (value - start) / (end - start);
}



StructuredBuffer<float2> Verts;
int VertCount;


float4 OutputColor(float2 pos)
{
    uint count = 0;
    float shortest = -1;
    // calculating shortest distance to edge
    for (int j = 0; j < VertCount; j++)
    {
        int index2 = j + 1;
        index2 = (index2 >= VertCount) ? 0 : index2;
        
        float currentdist = DistanceToLine(pos, Verts[j], Verts[index2]);
       
        
        if (shortest < 0 || shortest > currentdist)
        {
            shortest = currentdist;
        }
    }

    
    for (int i = 0; i < VertCount; i++)
    {
        int index2 = i + 1;
        index2 = (index2 >= VertCount) ? 0 : index2;
        
        if (pos.x < max(Verts[i].x,Verts[index2].x))
        {
            if (pos.y < max(Verts[i].y, Verts[index2].y))
            {
                if (pos.y >= min(Verts[i].y, Verts[index2].y))
                {
               
                    
                    float yintersect = lerp(Verts[i].x, Verts[index2].x, inverseLerp(Verts[i].y, Verts[index2].y, pos.y));

               
                    if (pos.x <= yintersect)
                    {
                        count++;

                    }
                    
                    
                    
                    
                }

            }

        }
        
    }
    
    
    if (count % 2 == 1)
    {
        return PrimaryColor;
    }
    else
    {
        return Blend(PrimaryColor, SecondaryColor, EaseInOut(saturate(shortest * 5.0),3), 1, false);
;
    }
    
 
}










[numthreads(8,8,1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{

    HandleMasking(OverrideWithMask, OverridePrimaryColor, PrimaryColor, SecondaryColor, SecondaryInputTexture[id.xy]);

    
    
    
    // TODO: insert actual code here!

    uint2 DistortedPosition = DistortPos((DistortionTex[id.xy]), id.xy, DistortionFactor);

    float2 pos = (float2)DistortedPosition;
    
    uint minlength = max(Dims.x, Dims.y);
    
    pos /= minlength;
    
   

    
    float4 OutColor = OutputColor(pos);
    
    Result[id.xy] = Blend(Result[id.xy], OutColor, OutColor.w, BlendMode, true);
    
    
    
    
}
